__includes [ "decision_context/context_actions.nls" "decision_context/context_time.nls" "decision_context/context_typical_actions.nls" "decision_context/context_needs.nls" ]

; This function is the same as in select_activity.nls, with the exception
; of calling conextual-deliberation-select-activity instead of
; my-preferred-available-activity-descriptor
to context-select-activity
  let c-a func-contextual-deliberation-select-activity
  ;let c-a my-preferred-available-activity-descriptor
  set deliberation-cost 0
  
  ;;select if migration takes over and people move around
  if (migration? and random-float 1 < probability-going-abroad) [
    set c-a (list away-gathering-point travelling-motive false)
  ]
  
  ;if who = 151 [ print (word "Chosen activity: " c-a) ]
  
  let loc location-of c-a
  select-activity-wtf? loc
  set current-activity loc
  set current-motivation motive-of c-a
  set chosen-available-activity-descriptor c-a
  set is-I-apply-social-distancing? social-distancing-of c-a
  if current-activity != away-gathering-point and current-motivation = travelling-motive [error "wrong place while travelling"]
  if log-violating-quarantine? [ process-quarantine-violation-event]
end

to-report func-contextual-deliberation-select-activity
  reset-delib-count
  ;if who = 151 [ print "Start deliberating" ]
  let tb-context get-context
  ;if who = 151 [ print tb-context ]
  ; Get typical action
  let list-context sort-by < (table:values tb-context)
  let typical-actions get-typical-actions list-context
  set delib-count-typical 1
  ;if who = 151 [ print (word "Typical actions: " typical-actions) ]
  if length typical-actions = 1 [ 
    update-delib-count
    report get-full-activity-from-string-action (first typical-actions)
  ]
  
  ; Action based on need
  if length typical-actions > 1
  [
    set delib-count-one-need 1
    let need-actions (get-actions-from-relevant-need-new tb-context typical-actions) ; get-actions-from-relevant-need-new can be changed to get-actions-from-relevant-need
    ;if who = 151 [ print (word "Need actions: " need-actions) ]
    if length need-actions = 1 [ 
      if (first need-actions) = action-imitate-network [
        set delib-count-one-need-conformity 1
        error "Conformity not implemented" ] ; Implement actual conformity, however not necessary since this is never the lowest need
      update-delib-count
      report get-full-activity-from-string-action (first need-actions) ]
    if length need-actions > 1 [
      set delib-count-one-need-multi-actions 1
      report get-full-activity-from-string-action (one-of need-actions)
    ]
  ]
  
  ; Do the full need based deliberation
  ;if who = 151 [ print (word "Full ASSOCC need based deliberation") ]
  set delib-count-full-need 1
  update-delib-count
  report my-preferred-available-activity-descriptor
end

; The values should be
to-report get-context
  let context table:make
  table:put context "time" slice-of-the-day
  ifelse is-working-day-for-me?
  [ table:put context "working-day" "is-working-day"]
  [ table:put context "working-day" "is-weekend-day"]
  if is-working-from-home-recommended? and age = worker-age ; Only relevant for people that work at a workplace (not at a school, uni, non-es/es shop, hospital)
  [ table:put context "recommendation" "work-from-home" ]
  report context
end

to-report get-typical-actions [context]
  ifelse table:has-key? table-typical-actions context
  [ report table:get table-typical-actions context ]
  [ report [] ]
end

; This function looks at all needs and determines the most urgent one, then looks for an action that satisfies this need
to-report get-actions-from-relevant-need [context typical-actions]
  let relevant-need (list get-most-urgent-need) ; Change to update decision context
  let actions-from-needs []
  if table:has-key? table-need-actions relevant-need
  [ set actions-from-needs (sentence actions-from-needs (table:get table-need-actions relevant-need))  ]
  if (table:get context "time" = time-morning or table:get context "time" = time-afternoon) and table:get context "working-day" = true
  [ if table:has-key? table-need-actions-working-hours relevant-need
    [ set actions-from-needs (sentence actions-from-needs (table:get table-need-actions-working-hours relevant-need)) ]
  ]
  ;if who = 151 [ print (word relevant-need ":" actions-from-needs) ]
  report intersect typical-actions actions-from-needs
end

; This function looks at all needs 'relevant to the actions' and determines the most urgent one, then looks for an action that satisfies this need
to-report get-actions-from-relevant-need-new [context typical-actions]
  let table-relevant-needs table:make
  foreach typical-actions
  [
    the-action -> if table:has-key? table-actions-with-related-needs the-action
    [
      foreach (table:get table-actions-with-related-needs the-action)
      [
        a-need -> if not (table:has-key? table-relevant-needs a-need)
        [
          table:put table-relevant-needs a-need (get-need-value a-need)
        ]
      ]
    ]
  ]
  if table:length table-relevant-needs = 0 [ report [] ]
  ;if who = 151 [ print table-relevant-needs ]
  let relevant-need (list get-most-urgent-need-from-table table-relevant-needs ) ; Change to update decision context
  ;if who = 151 [ print relevant-need]
  let actions-from-needs []
  if table:has-key? table-need-actions relevant-need
  [ set actions-from-needs (sentence actions-from-needs (table:get table-need-actions relevant-need))  ]
  if (table:get context "time" = time-morning or table:get context "time" = time-afternoon) and table:get context "working-day" = true
  [ if table:has-key? table-need-actions-working-hours relevant-need
    [ set actions-from-needs (sentence actions-from-needs (table:get table-need-actions-working-hours relevant-need)) ]
  ]
  ;if who = 151 [ print (word relevant-need ":" actions-from-needs) ]
  report intersect typical-actions actions-from-needs
end

to-report intersect [a b] ; Make more efficient
  let the-intersect []
  foreach a
  [
    x -> if member? x b
    [ set the-intersect (sentence the-intersect x) ]
  ]
  report the-intersect
end

to update-delib-count
  set delib-count-total-typical delib-count-typical
  set delib-count-total-one-need delib-count-one-need
  set delib-count-total-one-need-conformity delib-count-one-need-conformity
  set delib-count-total-one-need-multi-actions delib-count-one-need-multi-actions
  set delib-count-total-full-need delib-count-full-need
end

to reset-delib-count
  set delib-count-typical 0
  set delib-count-one-need 0
  set delib-count-one-need-conformity 0
  set delib-count-one-need-multi-actions 0
  set delib-count-full-need 0  
end
